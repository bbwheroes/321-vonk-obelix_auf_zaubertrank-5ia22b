=== Frontend Runtime View: User Interactions

This section describes the most important user interaction scenarios in the Vue + Vuetify frontend.
State is managed via a Pinia cart store.

==== Scenario 1: Browse catalog and add an item to cart

*Trigger:* The user clicks "ADD TO CART" on a product card in the shop grid.

*Main flow:*
. `Shop.vue` renders a list/grid of products and displays each product using `Card.vue`.
. In `Card.vue`, the user clicks the action button which emits `add-to-cart` with the selected product.
. `Shop.vue` forwards the emitted event to its parent (`UserView.vue`).
. `UserView.vue` forwards the event again via `$emit('add-to-cart', product)` to the `router-view`.
. `App.vue` listens to `@add-to-cart` on `<router-view>` and calls `cart.add(product)` in the Pinia store.
. `App.vue` opens the right-side navigation drawer to show the cart.

*Result:* The cart drawer opens and the item is visible in the cart.

*Relevant implementation files:*
- `components/Card.vue`
- `components/Shop.vue`
- `views/UserView.vue`
- `App.vue`
- `stores/cart.js`


==== Scenario 2: Change quantity in the cart drawer

*Trigger:* The user presses plus/minus buttons on an item inside the cart drawer.

*Main flow:*
. The drawer UI renders the cart content from the Pinia store (`cart.items`).
. The cart item component emits actions like `inc` / `dec`.
. `App.vue` (or the cart item component) calls `cart.inc(id)` or `cart.dec(id)` in the store.
. The store updates `qty` and removes items when quantity goes to zero.
. Computed totals (`totalCount`) update automatically and the UI re-renders.

*Result:* Quantities and totals update instantly without a page reload.

*Relevant implementation files:*
- `App.vue` (drawer + rendering)
- `stores/cart.js` (inc/dec logic)
- `components/BasketItem.vue` (UI trigger; emits inc/dec)


==== Scenario 3: Checkout and purchase

*Trigger:* The user opens checkout, selects offer allocations, and presses "Purchase".

*Main flow:*
. `Checkout.vue` reads the current `cart.items` from the Pinia store.
. The user allocates “offers” per cart item (local reactive state in `Checkout.vue`).
. `Checkout.vue` checks whether each cart item is “covered” (offered value >= required value).
. The "Purchase" button is enabled only when all cart items are covered (`canPurchase` computed).
. On purchase, `Checkout.vue` calls `cart.clear()`, resets local allocations and closes the dialog.

*Result:* The cart becomes empty and the checkout dialog closes.

*Relevant implementation files:*
- `components/Checkout.vue`
- `stores/cart.js`


=== Backend Runtime View: API Interactions

This section describes the most important runtime interaction scenarios in the backend API.
The backend follows a REST-based architecture and exposes functionality via dedicated endpoints.

==== Scenario 1: Retrieve product catalog

*Trigger:* The frontend loads the shop view and requests the available products.

*Main flow:*
. The frontend sends a `GET /menhirs` request to the backend API.
. The Menhir Controller receives the request and delegates it to the Menhir Service.
. The Menhir Service retrieves all available menhirs from the repository.
. The data is mapped to DTOs and returned as a JSON response.
. The frontend renders the received product list.

*Result:* The user sees the current catalog of available products.

*Relevant backend components:*
- `MenhirController`
- `MenhirService`
- `MenhirRepository`


==== Scenario 2: Create basket offer

*Trigger:* The user opens checkout and requests an offer calculation.

*Main flow:*
. The frontend sends a `POST /basket/offer` request with the current basket content.
. The Basket Controller validates the request payload.
. The Basket Service calculates required values per basket item.
. An offer summary is returned to the frontend.
. The frontend displays the offer allocations to the user.

*Result:* The frontend receives calculated offer requirements for the basket.

*Relevant backend components:*
- `BasketController`
- `BasketService`


==== Scenario 3: Purchase basket

*Trigger:* The user presses the "Purchase" button in the checkout dialog.

*Main flow:*
. The frontend sends a `POST /basket/buy` request with the final basket data.
. The Basket Controller validates the request.
. The Basket Service checks business rules and availability.
. The purchase is processed and persisted.
. The backend returns a success response.

*Result:* The purchase is completed and confirmed by the backend.

*Relevant backend components:*
- `BasketController`
- `BasketService`
- `OrderRepository`


==== Scenario 4: Leave basket

*Trigger:* The user cancels checkout or clears the basket.

*Main flow:*
. The frontend sends a `POST /basket/leave` request.
. The Basket Controller handles the request.
. No state is persisted on the backend.
. A confirmation response is returned.

*Result:* The basket session is terminated.

*Relevant backend components:*
- `BasketController`
