=== Backend / Microservices

==== *Mögliche Probleme*

[cols="1,2,1", options="header"]
|===
| Risiko | Beschreibung | Priorität

| *Keine zentrale Authentifizierung*
| Jeder Microservice kann aktuell eigenständig angesprochen werden. Ohne zentrales Authentifizierungs- und Autorisierungskonzept besteht ein hohes Sicherheitsrisiko.
| Kritisch

| *Fehlende Service-zu-Service Absicherung*
| Interne Kommunikation zwischen Microservices ist nicht abgesichert (z.B. kein mTLS, keine Token-Validierung).
| Hoch

| *Single Point of Failure*
| Zentrale Komponenten (z.B. API Gateway oder Datenbank) sind nicht redundant ausgelegt und können das Gesamtsystem lahmlegen.
| Hoch

| *Fehlendes Monitoring und Logging*
| Es existiert kein zentrales Logging oder Monitoring. Fehler in einzelnen Services sind schwer nachvollziehbar.
| Hoch

| *Keine klare Service-Grenzen*
| Business-Logik ist teilweise redundant oder unklar zwischen Services verteilt, was Wartbarkeit und Erweiterbarkeit erschwert.
| Mittel

| *Fehlendes Circuit Breaking*
| Bei Ausfall eines Services können abhängige Services ebenfalls blockieren oder abstürzen.
| Mittel

|===

==== *Lösungsansätze*

[cols="1,2", options="header"]
|===
| Risiko | Lösungsansatz

| *Keine zentrale Authentifizierung*
| Einführung eines zentralen Auth-Services (z.B. OAuth2 / OpenID Connect). JWT-basierte Authentifizierung über API Gateway.

| *Fehlende Service-zu-Service Absicherung*
| Absicherung interner Kommunikation mittels mTLS oder signierten Service-Tokens.

| *Single Point of Failure*
| Redundante Auslegung kritischer Komponenten. Einsatz von Load Balancern und Replikation.

| *Fehlendes Monitoring und Logging*
| Zentrales Logging (z.B. ELK Stack) und Monitoring (Prometheus, Grafana). Health Checks pro Service.

| *Keine klare Service-Grenzen*
| Klare Definition von Verantwortlichkeiten pro Microservice (Domain Driven Design).

| *Fehlendes Circuit Breaking*
| Einsatz von Resilience-Patterns wie Circuit Breaker, Retry und Timeout (z.B. Resilience4j).


|===
