ifndef::imagesdir[:imagesdir: ../images]

[[section-building-block-view]]
== Building Block View

=== Infrastructure Overview

==== Deployment Environment

The system runs on a **single VM** provisioned via the school-internal MaaS (Metal as a Service) platform.

[cols="1,3"]
|===
|Aspect |Description

|Platform
|School MaaS

|Lifetime
|1 month (ephemeral, data is lost on reprovisioning)

|Provisioning
|cloud-init script (`cloud-init.yaml`)

|Container Runtime
|Docker with Docker Compose

|Image Registry
|GitHub Container Registry (ghcr.io)
|===

==== Infrastructure Diagram

[plantuml, infrastructure-overview, svg]
----
@startuml
!theme plain

node "MaaS VM" {
    node "Docker" {
        component "menhir-webshop" as frontend
        component "obelix-webshop" as webshop
        component "obelix-basket" as basket
        component "obelix-quarry" as quarry
        
        component "Zipkin" as zipkin
        component "Prometheus" as prometheus
        component "Watchtower" as watchtower
    }
}

cloud "GitHub" {
    component "Container Registry\n(ghcr.io)" as ghcr
    component "GitHub Actions\n(CI/CD)" as actions
}

actor User

User --> frontend : ":80"
frontend --> webshop : ":8080"
webshop --> quarry : ":8081"
webshop --> basket : ":8082"

basket --> zipkin : "traces"
quarry --> zipkin : "traces"
webshop --> zipkin : "traces"

prometheus --> basket : "scrape :8080"
prometheus --> quarry : "scrape :8080"
prometheus --> webshop : "scrape :8080"

watchtower --> ghcr : "poll every 30s"
actions --> ghcr : "push images"

@enduml
----

==== Container Services

[cols="2,1,3"]
|===
|Service |Port |Purpose

|menhir-webshop
|80
|Frontend web application (static files)

|obelix-webshop
|8080
|Main backend API

|obelix-quarry
|8081
|Product catalog microservice

|obelix-basket
|8082
|Basket/cart microservice

|Zipkin
|9411
|Distributed tracing

|Prometheus
|9090
|Metrics collection (5s scrape interval)

|Watchtower
|—
|Auto-updates containers every 30s
|===

==== CI/CD Pipeline

The CI/CD pipeline runs on GitHub Actions with two workflows:

**Backend Tests** (`backend-tests.yml`)::
Triggered on any push to branches with changes in `backend/`. Runs integration tests using Docker Compose.

**Build & Push** (`deploy.yml`)::
Triggered on push to `main` and after successful backend tests. Builds and pushes Docker images.

[cols="1,3"]
|===
|Stage |Description

|Test
|Backend integration tests run on every push

|Build
|GitHub Actions builds Docker images on push to `main`

|Push
|Images pushed to `ghcr.io/bbwheroes/backend` and `ghcr.io/bbwheroes/menhir-webshop`

|Deploy
|Watchtower detects new images and redeploys automatically (30s polling)
|===

==== Operational Characteristics

Network Access::
The VM is only accessible from the school-internal network.

Automatic Updates::
Watchtower polls ghcr.io every 30 seconds. When a new `:latest` image is detected, the container is automatically replaced.

Observability::
* **Tracing**: All backend services send traces to Zipkin
* **Metrics**: Prometheus scrapes `/actuator/prometheus` every 5 seconds

Data Persistence::
Uses H2 in-memory database. All data is ephemeral and lost on container restart or VM reprovisioning.

Access Control::
SSH access is limited to the project owner (personal MaaS user account).
Die Building Block View zeigt die statische Zerlegung des Systems in Bausteine sowie deren Abhängigkeiten.

=== Level 1: Whitebox Gesamtsystem (Backend)

Hier beschreiben wir die wichtigsten Teile des Systems und wie sie interagieren.

[plantuml, level1-overview, svg]
----
@startuml
component "Basket API" <<Subsystem>> as Basket
component "Quarry API" <<Subsystem>> as Quarry

Basket ..> Quarry : "nutzt (Validierung & Bestandsprüfung)"
@enduml
----

**Beschreibung der Subsysteme:**
* **Basket API:** Verwaltet den Einkaufskorb und die Logik für den Tauschprozess.
* **Quarry API:** Verwaltet die Hinkelsteine und den Zugriff auf den Steinbruch.

---

=== Level 2: Whitebox der APIs

In diesem Level zeigen wir die interne Struktur der APIs, unterteilt in logische Building Blocks (Module).

==== Basket API (Warenkorb)

Die Basket API verwaltet den Einkaufskorb. Man kann sehen, was drin ist, Sachen reinlegen, alles rauswerfen oder den Inhalt gegen einen Stein tauschen.

[plantuml, level2-basket, svg]
----
@startuml
package "Basket API" {
    [BasketController] as Controller
    [BasketService] as Service
    [BasketRepository] as Repo
}
Controller -> Service
Service -> Repo
@enduml
----

**Wichtige Schnittstellen (Interfaces):**
* `GET /api/basket`: Zeigt den Inhalt des Korbs.
* `GET /api/basket/offer`: Legt etwas in den Korb.
* `DELETE /api/basket`: Leert den Korb.
* `POST /api/basket/buy/{menhirId}`: Tauscht den Korb-Inhalt gegen den Stein mit der ID `menhirId`.

==== Quarry API (Steinbruch)

Die Quarry API verwaltet die Hinkelsteine.

[plantuml, level2-quarry, svg]
----
@startuml
package "Quarry API" {
    [QuarryController] as Controller
    [QuarryService] as Service
    [QuarryRepository] as Repo
}
Controller -> Service
Service -> Repo
@enduml
----

**Schnittstellen:**
* `GET /api/menhirs`: Zeigt alle Steine.
* `GET /api/menhirs/{menhirId}`: Zeigt einen bestimmten Stein.
* `POST /api/menhirs`: Erstellt einen neuen Stein.
* `PUT /api/menhirs/{menhirId}`: Ändert einen Stein.
* `DELETE /api/quarry/{menhirId}`: Löscht einen Stein.

---

=== Level 3: Whitebox Datenstrukturen

Hier werden die internen Bausteine (Klassen/DTOs) detailliert, die für den Datenaustausch genutzt werden.

[plantuml, level3-data, svg]
----
@startuml
class BasketDto {
    +List<BasketItem> items
}
class BasketItem {
    +String name
    +Integer amount
}
class MenhirDto {
    +Long menhirId
    +String name
}
BasketDto "1" *-- "*" BasketItem
@enduml
----

**Wichtige Datenobjekte:**
* **BasketDto:** Der Korb mit einer Liste von Sachen.
* **BasketItem:** Ein Gegenstand im Korb (Name und Anzahl).
* **MenhirDto:** Ein Hinkelstein.
